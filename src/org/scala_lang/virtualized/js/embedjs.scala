package org.scala_lang.virtualized.js
import org.scala_lang.virtualized.{CoreDefs, CoreExps}


/**
 * JavaScript-specific definitions.
 */
trait JSDefsExps extends CoreDefs {
  // definitions, or statements -- their sequencing will be captured when they are converted to Exp's by toAtom
  case class IfThenElse[T](c: Exp[Boolean], a: Block[T], b: Block[T]) extends Def[T]
  case class VarInit[T](x: Exp[T]) extends Def[T]
  case class VarAssign[T](v: Exp[T], x: Exp[T]) extends Def[Unit]
  
  /**
   * The representation of a binary operation: we'll only use >= here 
   */
  case class BinaryOp[T, U](x: Exp[T], op: String, y: Exp[T]) extends Def[U]
  
  /**
   * Any T for which there is an implicit Ordering[T] will be converted into a BinaryOps[T],
   * so that >= appears to be available on these T's -- calling these operations will
   * yield a BinaryOp statement that represents the operation.
   */
  trait BinaryOps[T] { val self: Exp[T]
    def >=(y: Exp[T]) = BinaryOp[T, Boolean](self, ">=", y)
  }
  implicit def orderingOps[T: Ordering](x: Exp[T]) = new BinaryOps[T]{ val self = x }

  // Obj and Select are Exp's: used on their own (as a statement) in a DSL program, 
  // they will not generate any code (since toAtom is not called, and thus they are not registered in the current scope)
  // TODO: turn them into Def's, but it will work fine as long as they are used as part of Def's
  case class Select[T, U](tgt: Exp[U], field: String) extends Exp[T] {
    override def refStr: String = tgt.refStr +"."+ field
  }
  case class Obj[T](fields: Map[String, Exp[_]]) extends Exp[T] 

  case class Global[T](name: String) extends Exp[T]
  case class Invoke[T,U](tgt: Exp[U], name: String, args: List[Exp[_]]) extends Def[T]
}

trait EmbedJS extends JSDefsExps {
  // note the return types! toAtom will be used to turn the Def's into Exp's
  def __ifThenElse[T](cond: Exp[Boolean], thenp: Exp[T], elsep: Exp[T]): Exp[T] = IfThenElse(cond, reifyBlock(thenp), reifyBlock(elsep))
  def __newVar[T](x: Exp[T]): Exp[T] = VarInit(x)
  def __assign[T](lhs: Exp[T], rhs: Exp[T]): Exp[Unit] = VarAssign(lhs, rhs)

  // marker to trigger __new reification
  class JSObj extends Struct[Exp]

  def __new[T](args: (String, Exp[T] => Exp[_])*): Exp[T] = new Obj(args map {case (n, rhs) => (n, rhs(null))} toMap)

  implicit def selectOps(self: Exp[_ <: JSObj]) = new {
    def selectDynamic[T](n: String): Exp[T] = Select(self, n)
  }
  
  class DOM  
  def document: Exp[DOM] = Global[DOM]("document")
  def infix_getElementById(x: Exp[DOM], id: Exp[String]): Exp[DOM] = Invoke[DOM,DOM](x, "getElementById", List(id))
  def infix_innerHTML(x: Exp[DOM]): Exp[String] = Select(x, "innerHTML")
  def infix_foobar(x: Exp[DOM]): Exp[String] = Select(x, "innerHTML")
}

/**
 * An example embedded JavaScript program, for which code will be generated by running Test.
 * To run in Eclipse, right-click on "Test" below, and select Run As > Scala Application
 */
object Test extends App  {
  object Example extends EmbedJS with JSCodeGen { 
    def prog = {
      var kim = new JSObj { val name = "kim"; val age = 20 }
      kim.age = 21
      var allowedDrink = if (kim.age >= 21) "beer" else "milk"

      document.getElementById("drink").innerHTML = allowedDrink
    }
  }

  Example.emitFun("prog")(Example.prog) // output to console

  val html = {
      <html>
        <head>
          <title>Scala to JavaScript</title>
          <script type="text/javascript">
            { scala.xml.Unparsed(Example.captureOutput(Example.emitFun("prog")(Example.prog))) }
          </script>
        </head>
        <body onLoad="prog();">
          <h1>Kim drinks:</h1>
          <div id="drink">dunno</div>
        </body>
      </html>
    }

  scala.xml.XML.save("test.html", html)
}

/* emitted code: {
  var x1 = {"name" : "kim","age" : 20}
  var x2 = (x1.age = 21)
  if (x1.age >= 21) {
    var x3 = "beer"
  } else {
    var x3 = "milk"
  }
  var x4 = x3
  x4
} */


/** 
 * Rudimentary JavaScript code generation 
 * 
 * render Block, Def, and Expr as JavaScript code (printing to the console)
 */
trait JSCodeGen extends JSDefsExps {
  var nesting = 0
  var indent = true

  def emitValDef[T](s: Sym[T], rhs: String, more: Boolean = false) = {
    emitPlain("var " + s.refStr + " = " + rhs, more)
  }

  def emitPlain(s: String, more: Boolean = false) = {
    if (indent) print(" " * (nesting * 2))
    if (more) print(s) else println(s)
    indent = !more
  }

  def emitFun[T](name: String)(a: => Exp[T]) = {
    emitPlain("function " + name + "() ", true)
    emitBlock(reifyBlock(a))
  }

  def emitBlock[T](a: Block[T], more: Boolean = false, s: Sym[T] = null) = a match {
    case Block(stms, e) =>
      emitPlain("{", false); nesting += 1
        stms foreach { case t: ScopeEntry[t] => emitNode[t](t.sym, t.rhs) }

        if(s == null) emitPlain(e.refStr)
        else emitPlain(s.refStr + " = " + e.refStr)
      nesting -= 1; emitPlain("}", more)
  }

  def captureOutput(block: =>Unit): String = {
    val bstream = new java.io.ByteArrayOutputStream
    Console.withOut(new java.io.PrintStream(bstream))(block)
    bstream.toString
  }

  def emitNode[T](s: Sym[T], d: Def[T]): Unit = d match {
    case IfThenElse(c,a,b) => 
      emitPlain("var " + s.refStr)
      emitPlain("if (", true); emitExpr(c); emitPlain(") ", true)
      emitBlock(a, true, s)
      emitPlain(" else ", true)
      emitBlock(b, false, s)
    case VarInit(x) => 
      emitPlain("var " + s.refStr + " = ", true); emitExpr(x); emitPlain("")
    case VarAssign(v, x) => 
      emitValDef(s, "(" + v.refStr + " = ", true); emitExpr(x); emitPlain(")")
    case BinaryOp(x, op, y) =>
      emitValDef(s, "", true); emitExpr(x); emitPlain(" "+ op +" ", true); emitExpr(y); emitPlain("")
    case Invoke(x, m, args) => 
      emitValDef(s, x.refStr + "." + m + "(", true)
      args.init.foreach { e => emitExpr(e); emitPlain(",", true) }
      emitExpr(args.last)
      //args.map(e => emitExpr(e)).mkString(",") + ")")
      emitPlain(")")
  }

  override def quoteExp[T](x: Exp[T]): String = x match {
    case Global(name) => name
    case _ => super.quoteExp(x)
  }
  def emitExpr[T](expr: Exp[T]): Unit = expr match {
    case s@Sym(_) => emitPlain(s.refStr, true)
    case c@Const(_) => emitPlain(c.refStr, true); 
    case Global(name) => emitPlain(name, true)
    case Select(tgt, field) => emitExpr(tgt); emitPlain("."+field, true)
    case Obj(fields) =>
      emitPlain("{", true)
      if(fields nonEmpty) {
        fields.head match { case (n, v) => emitPlain("\""+ n +"\" : ", true); emitExpr(v)}
        fields.tail foreach {case (n, v) => emitPlain(",", true); emitPlain("\""+ n +"\" : ", true); emitExpr(v)}
      }
      emitPlain("}", true)
  }
}